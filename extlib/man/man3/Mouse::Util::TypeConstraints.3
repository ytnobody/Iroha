.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mouse::Util::TypeConstraints 3"
.TH Mouse::Util::TypeConstraints 3 "2011-10-10" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mouse::Util::TypeConstraints \- Type constraint system for Mouse
.SH "VERSION"
.IX Header "VERSION"
This document describes Mouse version 0.97
.SS "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 1
\&  use Mouse::Util::TypeConstraints;
\&
\&  subtype \*(AqNatural\*(Aq
\&      => as \*(AqInt\*(Aq
\&      => where { $_ > 0 };
\&
\&  subtype \*(AqNaturalLessThanTen\*(Aq
\&      => as \*(AqNatural\*(Aq
\&      => where { $_ < 10 }
\&      => message { "This number ($_) is not less than ten!" };
\&
\&  coerce \*(AqNum\*(Aq
\&      => from \*(AqStr\*(Aq
\&        => via { 0+$_ };
\&
\&  enum \*(AqRGBColors\*(Aq => qw(red green blue);
\&
\&  no Mouse::Util::TypeConstraints;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides Mouse with the ability to create custom type
constraints to be used in attribute definition.
.SS "Important Caveat"
.IX Subsection "Important Caveat"
This is \fB\s-1NOT\s0\fR a type system for Perl 5. These are type constraints,
and they are not used by Mouse unless you tell it to. No type
inference is performed, expressions are not typed, etc. etc. etc.
.PP
A type constraint is at heart a small \*(L"check if a value is valid\*(R"
function. A constraint can be associated with an attribute. This
simplifies parameter validation, and makes your code clearer to read,
because you can refer to constraints by name.
.SS "Slightly Less Important Caveat"
.IX Subsection "Slightly Less Important Caveat"
It is \fBalways\fR a good idea to quote your type names.
.PP
This prevents Perl from trying to execute the call as an indirect
object call. This can be an issue when you have a subtype with the
same name as a valid class.
.PP
For instance:
.PP
.Vb 1
\&  subtype DateTime => as Object => where { $_\->isa(\*(AqDateTime\*(Aq) };
.Ve
.PP
will \fIjust work\fR, while this:
.PP
.Vb 2
\&  use DateTime;
\&  subtype DateTime => as Object => where { $_\->isa(\*(AqDateTime\*(Aq) };
.Ve
.PP
will fail silently and cause many headaches. The simple way to solve
this, as well as future proof your subtypes from classes which have
yet to have been created, is to quote the type name:
.PP
.Vb 2
\&  use DateTime;
\&  subtype \*(AqDateTime\*(Aq => as \*(AqObject\*(Aq => where { $_\->isa(\*(AqDateTime\*(Aq) };
.Ve
.SS "Default Type Constraints"
.IX Subsection "Default Type Constraints"
This module also provides a simple hierarchy for Perl 5 types, here is
that hierarchy represented visually.
.PP
.Vb 10
\& Any
\&  Item
\&      Bool
\&      Maybe[\`a]
\&      Undef
\&      Defined
\&          Value
\&              Str
\&                  Num
\&                      Int
\&                  ClassName
\&                  RoleName
\&          Ref
\&              ScalarRef
\&              ArrayRef[\`a]
\&              HashRef[\`a]
\&              CodeRef
\&              RegexpRef
\&              GlobRef
\&                  FileHandle
\&              Object
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Any type followed by a type parameter \f(CW\*(C`[\`a]\*(C'\fR can be
parameterized, this means you can say:
.PP
.Vb 3
\&  ArrayRef[Int]    # an array of integers
\&  HashRef[CodeRef] # a hash of str to CODE ref mappings
\&  Maybe[Str]       # value may be a string, may be undefined
.Ve
.PP
If Mouse finds a name in brackets that it does not recognize as an
existing type, it assumes that this is a class name, for example
\&\f(CW\*(C`ArrayRef[DateTime]\*(C'\fR.
.PP
\&\fB\s-1NOTE:\s0\fR The \f(CW\*(C`Undef\*(C'\fR type constraint for the most part works
correctly now, but edge cases may still exist, please use it
sparingly.
.PP
\&\fB\s-1NOTE:\s0\fR The \f(CW\*(C`ClassName\*(C'\fR type constraint does a complex package
existence check. This means that your class \fBmust\fR be loaded for this
type constraint to pass.
.PP
\&\fB\s-1NOTE:\s0\fR The \f(CW\*(C`RoleName\*(C'\fR constraint checks a string is a \fIpackage
name\fR which is a role, like \f(CW\*(AqMyApp::Role::Comparable\*(Aq\fR. The \f(CW\*(C`Role\*(C'\fR
constraint checks that an \fIobject does\fR the named role.
.SS "Type Constraint Naming"
.IX Subsection "Type Constraint Naming"
Type name declared via this module can only contain alphanumeric
characters, colons (:), and periods (.).
.PP
Since the types created by this module are global, it is suggested
that you namespace your types just as you would namespace your
modules. So instead of creating a \fIColor\fR type for your
\&\fBMy::Graphics\fR module, you would call the type
\&\fIMy::Graphics::Types::Color\fR instead.
.SS "Use with Other Constraint Modules"
.IX Subsection "Use with Other Constraint Modules"
This module can play nicely with other constraint modules with some
slight tweaking. The \f(CW\*(C`where\*(C'\fR clause in types is expected to be a
\&\f(CW\*(C`CODE\*(C'\fR reference which checks it's first argument and returns a
boolean. Since most constraint modules work in a similar way, it
should be simple to adapt them to work with Mouse.
.PP
For instance, this is how you could use it with
Declare::Constraints::Simple to declare a completely new type.
.PP
.Vb 7
\&  type \*(AqHashOfArrayOfObjects\*(Aq,
\&      {
\&      where => IsHashRef(
\&          \-keys   => HasLength,
\&          \-values => IsArrayRef(IsObject)
\&      )
\&  };
.Ve
.PP
Here is an example of using Test::Deep and it's non-test
related \f(CW\*(C`eq_deeply\*(C'\fR function.
.PP
.Vb 8
\&  type \*(AqArrayOfHashOfBarsAndRandomNumbers\*(Aq
\&      => where {
\&          eq_deeply($_,
\&              array_each(subhashof({
\&                  bar           => isa(\*(AqBar\*(Aq),
\&                  random_number => ignore()
\&              })))
\&        };
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """list_all_builtin_type_constraints \-> (Names)"""
.el .SS "\f(CWlist_all_builtin_type_constraints \-> (Names)\fP"
.IX Subsection "list_all_builtin_type_constraints -> (Names)"
Returns the names of builtin type constraints.
.ie n .SS """list_all_type_constraints \-> (Names)"""
.el .SS "\f(CWlist_all_type_constraints \-> (Names)\fP"
.IX Subsection "list_all_type_constraints -> (Names)"
Returns the names of all the type constraints.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """type $name => where { } ... \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWtype $name => where { } ... \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "type $name => where { } ... -> Mouse::Meta::TypeConstraint"
.PD 0
.ie n .IP """subtype $name => as $parent => where { } ... \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWsubtype $name => as $parent => where { } ... \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "subtype $name => as $parent => where { } ... -> Mouse::Meta::TypeConstraint"
.ie n .IP """subtype as $parent => where { } ...  \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWsubtype as $parent => where { } ...  \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "subtype as $parent => where { } ...  -> Mouse::Meta::TypeConstraint"
.ie n .IP """class_type ($class, ?$options) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWclass_type ($class, ?$options) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "class_type ($class, ?$options) -> Mouse::Meta::TypeConstraint"
.ie n .IP """role_type ($role, ?$options) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWrole_type ($role, ?$options) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "role_type ($role, ?$options) -> Mouse::Meta::TypeConstraint"
.ie n .IP """duck_type($name, @methods | \e@methods) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWduck_type($name, @methods | \e@methods) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "duck_type($name, @methods | @methods) -> Mouse::Meta::TypeConstraint"
.ie n .IP """duck_type(\e@methods) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWduck_type(\e@methods) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "duck_type(@methods) -> Mouse::Meta::TypeConstraint"
.ie n .IP """enum($name, @values | \e@values) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWenum($name, @values | \e@values) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "enum($name, @values | @values) -> Mouse::Meta::TypeConstraint"
.ie n .IP """enum (\e@values) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWenum (\e@values) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "enum (@values) -> Mouse::Meta::TypeConstraint"
.ie n .IP """coerce $type => from $another_type, via { }, ...""" 4
.el .IP "\f(CWcoerce $type => from $another_type, via { }, ...\fR" 4
.IX Item "coerce $type => from $another_type, via { }, ..."
.ie n .IP """find_type_constraint(Type) \-> Mouse::Meta::TypeConstraint""" 4
.el .IP "\f(CWfind_type_constraint(Type) \-> Mouse::Meta::TypeConstraint\fR" 4
.IX Item "find_type_constraint(Type) -> Mouse::Meta::TypeConstraint"
.PD
.SH "THANKS"
.IX Header "THANKS"
Much of this documentation was taken from \f(CW\*(C`Moose::Util::TypeConstraints\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Moose::Util::TypeConstraints
