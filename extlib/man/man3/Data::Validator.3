.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Validator 3"
.TH Data::Validator 3 "2012-02-16" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Validator \- Rule based validator on type constraint system
.SH "VERSION"
.IX Header "VERSION"
This document describes Data::Validator version 0.09.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use 5.10.0;
\&    use Data::Validator;
\&
\&    # for functions
\&    sub get {
\&        state $rule = Data::Validator\->new(
\&            uri        => { isa => \*(AqStr\*(Aq, xor => [qw(schema host path_query)] },
\&
\&            schema     => { isa => \*(AqStr\*(Aq, default => \*(Aqhttp\*(Aq },
\&            host       => { isa => \*(AqStr\*(Aq },
\&            path_query => { isa => \*(AqStr\*(Aq, default => \*(Aq/\*(Aq },
\&
\&            method     => { isa => \*(AqStr\*(Aq, default => \*(AqGET\*(Aq },
\&        );
\&
\&        my $args = $rule\->validate(@_);
\&        # ...
\&    }
\&    get( uri => \*(Aqhttp://example.com/\*(Aq );
\&
\&    # for methods
\&    sub method {
\&        state $rule = Data::Validator\->new(
\&            foo => \*(AqStr\*(Aq,
\&        )\->with(\*(AqMethod\*(Aq);
\&
\&        my($self, $args) = $rule\->validate(@_);
\&        # ...
\&    }
\&    Foo\->method( foo => \*(Aqbar\*(Aq );
\&
\&
\&    # using sequenced parameters
\&    sub seq {
\&        state $rule = Data::Validator\->new(
\&            foo => \*(AqStr\*(Aq,
\&        )\->with(\*(AqStrictSequenced\*(Aq);
\&
\&        my $args = $rule\->validate(@_);
\&        # ...
\&    }
\&    seq( \*(Aqbar\*(Aq );          # seq() will get { foo => \*(Aqbar\*(Aq }
\&    seq({ foo => \*(Aqbar\*(Aq }); # named style are available!
\&
\&
\&    # using Method and StrictSequenced together
\&    sub seq_method {
\&        state $rule = Data::Validator\->new(
\&            foo => \*(AqStr\*(Aq,
\&        )\->with( \*(AqMethod\*(Aq, \*(AqStrictSequenced\*(Aq);
\&
\&        my($self, $args) = $rule\->validate(@_);
\&        # ...
\&    }
\&    Foo\->seq_method( \*(Aqbar\*(Aq ); # seq() will get { foo => \*(Aqbar\*(Aq }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is yet another validation library, based on \f(CW\*(C`Smart::Args\*(C'\fR but
less smart.
.PP
This is designed for general data validation. For example, it is useful for \s-1CSV\s0, \s-1JSON\s0, \s-1XML\s0, and so on.
.SS "Concepts"
.IX Subsection "Concepts"
.IP "Natural as Perl code" 4
.IX Item "Natural as Perl code"
I love \f(CW\*(C`Smart::Args\*(C'\fR because it is really stylish, but it does not seem
Perl-ish.
.Sp
Thus, I have designed \f(CW\*(C`Data::Validator\*(C'\fR in more Perl-ish way
with full of \f(CW\*(C`Smart::Args\*(C'\fR functionality.
.IP "Basics on type constraint system" 4
.IX Item "Basics on type constraint system"
Moose's type constraint system is awesome, and so is Mouse's. In fact,
Mouse's type constraints are much faster than Moose's so that you need not
hesitate to check types.
.Sp
Thus, I have made \f(CW\*(C`Data::Validator\*(C'\fR on Mouse's type constraint system.
.IP "Pure Perl" 4
.IX Item "Pure Perl"
Although I do not hesitate to depend on \s-1XS\s0 modules, some people think that
\&\s-1XS\s0 modules are hard to install.
.Sp
Thus, I have written \f(CW\*(C`Data::Validator\*(C'\fR in pure Perl and selected dependent
modules which work in pure Perl.
.IP "Performance" 4
.IX Item "Performance"
Validators should be as fast as possible because they matter only for illegal
inputs. Otherwise, one would want something like \fIno validation\fR option.
.Sp
This is much faster than \f(CW\*(C`Params::Validate\*(C'\fR, which has an \s-1XS\s0 backend, though.
.SH "INTERFACE"
.IX Header "INTERFACE"
.ie n .SS """Data::Validator\->new( $arg_name => $rule [, ...]) :Validator"""
.el .SS "\f(CWData::Validator\->new( $arg_name => $rule [, ...]) :Validator\fP"
.IX Subsection "Data::Validator->new( $arg_name => $rule [, ...]) :Validator"
Creates a validation rule. You should cache the rules for performance.
.PP
Attributes for \fI\f(CI$rule\fI\fR are as follows:
.ie n .IP """isa => $type : Str|Object""" 4
.el .IP "\f(CWisa => $type : Str|Object\fR" 4
.IX Item "isa => $type : Str|Object"
The type of the rule, which can be a Mouse type constraint name, a class name,
or a type constraint object of either Mouse or Moose (i.e. it's duck-typed).
.ie n .IP """does => $role : Str|Object""" 4
.el .IP "\f(CWdoes => $role : Str|Object\fR" 4
.IX Item "does => $role : Str|Object"
The type of the rule, which can be a Mouse type constraint name, a role name,
or a type constraint object of either Mouse or Moose (i.e. it's duck-typed).
.Sp
Note that you cannot use it with the \f(CW\*(C`isa\*(C'\fR attribute.
.ie n .IP """coerce => $should_coercion : Bool""" 4
.el .IP "\f(CWcoerce => $should_coercion : Bool\fR" 4
.IX Item "coerce => $should_coercion : Bool"
If false, the rule does not try to coerce when the validation fails.
Default to true.
.ie n .IP """default=> $value : Any | CodeRef""" 4
.el .IP "\f(CWdefault=> $value : Any | CodeRef\fR" 4
.IX Item "default=> $value : Any | CodeRef"
The default value for the argument.
If it is a \s-1CODE\s0 reference, it is called in scalar context as
\&\f(CW\*(C`$default\->($validator, $rule, $args)\*(C'\fR and its return value
is used as a default value.
.Sp
Because arguments are validated in the order of definitions, \f(CW\*(C`default\*(C'\fR
callbacks can rely on the previously-filled values:
.Sp
.Vb 9
\&    my $v = Data::Validator\->new(
\&        foo => { default => 99 },
\&        bar => { default => sub {
\&            my($validator, $this_rule, $args) = @_;
\&            return $args\->{foo} + 1;
\&        } },
\&    );
\&    $v\->validate();          # bar is 100
\&    $v\->validate(foo => 42); # bar is 43
.Ve
.Sp
Unlike Moose/Mouse's \f(CW\*(C`default\*(C'\fR, any references are allowed, but note that
they are statically allocated.
.ie n .IP """optional => $value : Bool""" 4
.el .IP "\f(CWoptional => $value : Bool\fR" 4
.IX Item "optional => $value : Bool"
If true, users can omit the argument. Default to false.
.ie n .IP """xor => $exclusives : ArrayRef""" 4
.el .IP "\f(CWxor => $exclusives : ArrayRef\fR" 4
.IX Item "xor => $exclusives : ArrayRef"
Exclusive arguments, which users cannot pass together.
.ie n .IP """documentation => $doc : Str""" 4
.el .IP "\f(CWdocumentation => $doc : Str\fR" 4
.IX Item "documentation => $doc : Str"
Descriptions of the argument.
.Sp
This is not yet used anywhere.
.ie n .SS """$validator\->find_rule($name :Str)"""
.el .SS "\f(CW$validator\->find_rule($name :Str)\fP"
.IX Subsection "$validator->find_rule($name :Str)"
Finds the rule named \fI\f(CI$name\fI\fR. Provided for error handling.
.ie n .SS """$validator\->with(@extentions) :Validator"""
.el .SS "\f(CW$validator\->with(@extentions) :Validator\fP"
.IX Subsection "$validator->with(@extentions) :Validator"
Applies \fI\f(CI@extentions\fI\fR to \fI\f(CI$validator\fI\fR and returns itself.
.PP
See \*(L"\s-1EXTENTIONS\s0\*(R" for details.
.ie n .SS """$validator\->validate(@args) :HashRef"""
.el .SS "\f(CW$validator\->validate(@args) :HashRef\fP"
.IX Subsection "$validator->validate(@args) :HashRef"
Validates \fI\f(CI@args\fI\fR and returns a restricted \s-1HASH\s0 reference.
.PP
Restricted hashes are hashes which do not allow to access non-existing keys,
so you must check a key \f(CW\*(C`exists\*(C'\fR in the hash before fetching its values.
.SH "EXTENTIONS"
.IX Header "EXTENTIONS"
There are extentions which changes behaviours of \f(CW\*(C`validate()\*(C'\fR.
.SS "Method"
.IX Subsection "Method"
Takes the first argument as an invocant (i.e. class or object instance),
and returns it as the first value:
.PP
.Vb 1
\&    my($invocant, $args) = $rule\->validate(@_);
.Ve
.SS "StrictSequenced"
.IX Subsection "StrictSequenced"
Deals with arguments in sequenced style, where users should pass
arguments by the order of argument rules, instead of by-name.
.SS "Sequenced"
.IX Subsection "Sequenced"
Deals with arguments in sequenced style, where users should pass
arguments by the order of argument rules, instead of by-name.
.PP
Note that if the last argument is a \s-1HASH\s0 reference, it is regarded as
named-style arguments.
.SS "AllowExtra"
.IX Subsection "AllowExtra"
Regards unknown arguments as extra arguments, and returns them as
a list of name-value pairs:
.PP
.Vb 1
\&    my($args, %extra) = $rule\->validate(@_);
.Ve
.SS "NoThrow"
.IX Subsection "NoThrow"
Does not throw errors. Instead, it provides validators with the \f(CW\*(C`errors\*(C'\fR
attribute:
.PP
.Vb 8
\&    my $args = $v\->validate(@_); # it never throws errors
\&    if($v\->has_errors) {
\&        my $errors = $v\->clear_errors;
\&        foreach my $e(@{$errors}) {
\&            # $e has \*(Aqtype\*(Aq, \*(Aqmessage\*(Aq and \*(Aqname\*(Aq
\&            print $e\->{message}, "\en";
\&        }
\&    }
.Ve
.SS "Croak"
.IX Subsection "Croak"
Does not report stack backtraces on errors, i.e. uses \f(CW\*(C`croak()\*(C'\fR instead
of \f(CW\*(C`confess()\*(C'\fR to throw errors.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Perl 5.8.1 or later.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Smart::Args
.PP
Params::Validate
.PP
Sub::Args
.PP
MooseX::Params::Validate
.PP
Mouse
.SH "AUTHOR"
.IX Header "AUTHOR"
Fuji, Goro (gfx) <gfuji@cpan.org>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2010, Fuji Goro (gfx). All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
